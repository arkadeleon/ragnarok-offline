//
//  SkillInfoFlag2.swift
//  RagnarokOffline
//
//  Generated by ROCodeGenerator.
//

/// Converted from `e_skill_inf2` in `map/skill.hpp`.
public enum SkillInfoFlag2: Int, CaseIterable, Sendable {
    case isquest = 0
    case isnpc = 1
    case iswedding = 2
    case isspirit = 3
    case isguild = 4
    case issong = 5
    case isensemble = 6
    case istrap = 7
    case targetself = 8
    case notargetself = 9
    case partyonly = 10
    case guildonly = 11
    case notargetenemy = 12
    case isautoshadowspell = 13
    case ischorus = 14
    case ignorebgreduction = 15
    case ignoregvgreduction = 16
    case disablenearnpc = 17
    case targettrap = 18
    case ignorelandprotector = 19
    case allowwhenhidden = 20
    case allowwhenperforming = 21
    case targetemperium = 22
    case ignorekagehumi = 23
    case alterrangevulture = 24
    case alterrangesnakeeye = 25
    case alterrangeshadowjump = 26
    case alterrangeradius = 27
    case alterrangeresearchtrap = 28
    case ignorehovering = 29
    case allowonwarg = 30
    case allowonmado = 31
    case targetmanhole = 32
    case targethidden = 33
    case increasedancewithwugdamage = 34
    case ignorewugbite = 35
    case ignoreautoguard = 36
    case ignorecicada = 37
    case showscale = 38
    case ignoregtb = 39
    case toggleable = 40
}

extension SkillInfoFlag2: CodingKey {
    public var stringValue: String {
        switch self {
        case .isquest: "ISQUEST"
        case .isnpc: "ISNPC"
        case .iswedding: "ISWEDDING"
        case .isspirit: "ISSPIRIT"
        case .isguild: "ISGUILD"
        case .issong: "ISSONG"
        case .isensemble: "ISENSEMBLE"
        case .istrap: "ISTRAP"
        case .targetself: "TARGETSELF"
        case .notargetself: "NOTARGETSELF"
        case .partyonly: "PARTYONLY"
        case .guildonly: "GUILDONLY"
        case .notargetenemy: "NOTARGETENEMY"
        case .isautoshadowspell: "ISAUTOSHADOWSPELL"
        case .ischorus: "ISCHORUS"
        case .ignorebgreduction: "IGNOREBGREDUCTION"
        case .ignoregvgreduction: "IGNOREGVGREDUCTION"
        case .disablenearnpc: "DISABLENEARNPC"
        case .targettrap: "TARGETTRAP"
        case .ignorelandprotector: "IGNORELANDPROTECTOR"
        case .allowwhenhidden: "ALLOWWHENHIDDEN"
        case .allowwhenperforming: "ALLOWWHENPERFORMING"
        case .targetemperium: "TARGETEMPERIUM"
        case .ignorekagehumi: "IGNOREKAGEHUMI"
        case .alterrangevulture: "ALTERRANGEVULTURE"
        case .alterrangesnakeeye: "ALTERRANGESNAKEEYE"
        case .alterrangeshadowjump: "ALTERRANGESHADOWJUMP"
        case .alterrangeradius: "ALTERRANGERADIUS"
        case .alterrangeresearchtrap: "ALTERRANGERESEARCHTRAP"
        case .ignorehovering: "IGNOREHOVERING"
        case .allowonwarg: "ALLOWONWARG"
        case .allowonmado: "ALLOWONMADO"
        case .targetmanhole: "TARGETMANHOLE"
        case .targethidden: "TARGETHIDDEN"
        case .increasedancewithwugdamage: "INCREASEDANCEWITHWUGDAMAGE"
        case .ignorewugbite: "IGNOREWUGBITE"
        case .ignoreautoguard: "IGNOREAUTOGUARD"
        case .ignorecicada: "IGNORECICADA"
        case .showscale: "SHOWSCALE"
        case .ignoregtb: "IGNOREGTB"
        case .toggleable: "TOGGLEABLE"
        }
    }

    public init?(stringValue: String) {
        switch stringValue.uppercased() {
        case "ISQUEST": self = .isquest
        case "ISNPC": self = .isnpc
        case "ISWEDDING": self = .iswedding
        case "ISSPIRIT": self = .isspirit
        case "ISGUILD": self = .isguild
        case "ISSONG": self = .issong
        case "ISENSEMBLE": self = .isensemble
        case "ISTRAP": self = .istrap
        case "TARGETSELF": self = .targetself
        case "NOTARGETSELF": self = .notargetself
        case "PARTYONLY": self = .partyonly
        case "GUILDONLY": self = .guildonly
        case "NOTARGETENEMY": self = .notargetenemy
        case "ISAUTOSHADOWSPELL": self = .isautoshadowspell
        case "ISCHORUS": self = .ischorus
        case "IGNOREBGREDUCTION": self = .ignorebgreduction
        case "IGNOREGVGREDUCTION": self = .ignoregvgreduction
        case "DISABLENEARNPC": self = .disablenearnpc
        case "TARGETTRAP": self = .targettrap
        case "IGNORELANDPROTECTOR": self = .ignorelandprotector
        case "ALLOWWHENHIDDEN": self = .allowwhenhidden
        case "ALLOWWHENPERFORMING": self = .allowwhenperforming
        case "TARGETEMPERIUM": self = .targetemperium
        case "IGNOREKAGEHUMI": self = .ignorekagehumi
        case "ALTERRANGEVULTURE": self = .alterrangevulture
        case "ALTERRANGESNAKEEYE": self = .alterrangesnakeeye
        case "ALTERRANGESHADOWJUMP": self = .alterrangeshadowjump
        case "ALTERRANGERADIUS": self = .alterrangeradius
        case "ALTERRANGERESEARCHTRAP": self = .alterrangeresearchtrap
        case "IGNOREHOVERING": self = .ignorehovering
        case "ALLOWONWARG": self = .allowonwarg
        case "ALLOWONMADO": self = .allowonmado
        case "TARGETMANHOLE": self = .targetmanhole
        case "TARGETHIDDEN": self = .targethidden
        case "INCREASEDANCEWITHWUGDAMAGE": self = .increasedancewithwugdamage
        case "IGNOREWUGBITE": self = .ignorewugbite
        case "IGNOREAUTOGUARD": self = .ignoreautoguard
        case "IGNORECICADA": self = .ignorecicada
        case "SHOWSCALE": self = .showscale
        case "IGNOREGTB": self = .ignoregtb
        case "TOGGLEABLE": self = .toggleable
        default: return nil
        }
    }

    public var intValue: Int? {
        rawValue
    }

    public init?(intValue: Int) {
        self.init(rawValue: intValue)
    }
}

extension SkillInfoFlag2: CodingKeyRepresentable {
    public var codingKey: any CodingKey {
        self
    }

    public init?<T>(codingKey: T) where T: CodingKey {
        self.init(stringValue: codingKey.stringValue)
    }
}

extension SkillInfoFlag2: Decodable {
    public init(from decoder: any Decoder) throws {
        let container = try decoder.singleValueContainer()
        let stringValue = try container.decode(String.self)
        if let value = Self.init(stringValue: stringValue) {
            self = value
        } else {
            throw DecodingError.dataCorruptedError(in: container, debugDescription: "Could not initialize \(Self.self) from invalid string value \(stringValue)")
        }
    }
}
