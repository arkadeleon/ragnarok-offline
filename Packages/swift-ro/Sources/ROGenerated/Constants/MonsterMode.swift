//
//  MonsterMode.swift
//  RagnarokOffline
//
//  Generated by ROGenerator.
//

/// Converted from `e_mode` in `common/mmo.hpp`.
public enum MonsterMode: Int, CaseIterable, Sendable {
    case canmove = 0x1
    case looter = 0x2
    case aggressive = 0x4
    case assist = 0x8
    case castsensoridle = 0x10
    case norandomwalk = 0x20
    case nocast = 0x40
    case canattack = 0x80
    case castsensorchase = 0x200
    case changechase = 0x400
    case angry = 0x800
    case changetargetmelee = 0x1000
    case changetargetchase = 0x2000
    case targetweak = 0x4000
    case randomtarget = 0x8000
    case ignoremelee = 0x10000
    case ignoremagic = 0x20000
    case ignoreranged = 0x40000
    case mvp = 0x80000
    case ignoremisc = 0x100000
    case knockbackimmune = 0x200000
    case teleportblock = 0x400000
    case fixeditemdrop = 0x1000000
    case detector = 0x2000000
    case statusimmune = 0x4000000
    case skillimmune = 0x8000000
}

extension MonsterMode: CodingKey {
    public var stringValue: String {
        switch self {
        case .canmove: "CANMOVE"
        case .looter: "LOOTER"
        case .aggressive: "AGGRESSIVE"
        case .assist: "ASSIST"
        case .castsensoridle: "CASTSENSORIDLE"
        case .norandomwalk: "NORANDOMWALK"
        case .nocast: "NOCAST"
        case .canattack: "CANATTACK"
        case .castsensorchase: "CASTSENSORCHASE"
        case .changechase: "CHANGECHASE"
        case .angry: "ANGRY"
        case .changetargetmelee: "CHANGETARGETMELEE"
        case .changetargetchase: "CHANGETARGETCHASE"
        case .targetweak: "TARGETWEAK"
        case .randomtarget: "RANDOMTARGET"
        case .ignoremelee: "IGNOREMELEE"
        case .ignoremagic: "IGNOREMAGIC"
        case .ignoreranged: "IGNORERANGED"
        case .mvp: "MVP"
        case .ignoremisc: "IGNOREMISC"
        case .knockbackimmune: "KNOCKBACKIMMUNE"
        case .teleportblock: "TELEPORTBLOCK"
        case .fixeditemdrop: "FIXEDITEMDROP"
        case .detector: "DETECTOR"
        case .statusimmune: "STATUSIMMUNE"
        case .skillimmune: "SKILLIMMUNE"
        }
    }

    public init?(stringValue: String) {
        switch stringValue.uppercased() {
        case "CANMOVE": self = .canmove
        case "LOOTER": self = .looter
        case "AGGRESSIVE": self = .aggressive
        case "ASSIST": self = .assist
        case "CASTSENSORIDLE": self = .castsensoridle
        case "NORANDOMWALK": self = .norandomwalk
        case "NOCAST": self = .nocast
        case "CANATTACK": self = .canattack
        case "CASTSENSORCHASE": self = .castsensorchase
        case "CHANGECHASE": self = .changechase
        case "ANGRY": self = .angry
        case "CHANGETARGETMELEE": self = .changetargetmelee
        case "CHANGETARGETCHASE": self = .changetargetchase
        case "TARGETWEAK": self = .targetweak
        case "RANDOMTARGET": self = .randomtarget
        case "IGNOREMELEE": self = .ignoremelee
        case "IGNOREMAGIC": self = .ignoremagic
        case "IGNORERANGED": self = .ignoreranged
        case "MVP": self = .mvp
        case "IGNOREMISC": self = .ignoremisc
        case "KNOCKBACKIMMUNE": self = .knockbackimmune
        case "TELEPORTBLOCK": self = .teleportblock
        case "FIXEDITEMDROP": self = .fixeditemdrop
        case "DETECTOR": self = .detector
        case "STATUSIMMUNE": self = .statusimmune
        case "SKILLIMMUNE": self = .skillimmune
        default: return nil
        }
    }

    public var intValue: Int? {
        rawValue
    }

    public init?(intValue: Int) {
        self.init(rawValue: intValue)
    }
}

extension MonsterMode: CodingKeyRepresentable {
    public var codingKey: any CodingKey {
        self
    }

    public init?<T>(codingKey: T) where T: CodingKey {
        self.init(stringValue: codingKey.stringValue)
    }
}

extension MonsterMode: Decodable {
    public init(from decoder: any Decoder) throws {
        let container = try decoder.singleValueContainer()
        let stringValue = try container.decode(String.self)
        if let value = Self.init(stringValue: stringValue) {
            self = value
        } else {
            throw DecodingError.dataCorruptedError(in: container, debugDescription: "Could not initialize \(Self.self) from invalid string value \(stringValue)")
        }
    }
}
