//
//  SkillDamageFlag.swift
//  RagnarokOffline
//
//  Generated by ROGenerator.
//

/// Converted from `e_skill_nk` in `map/skill.hpp`.
public enum SkillDamageFlag: CaseIterable, RawRepresentable, Sendable {
    case nodamage
    case splash
    case splashsplit
    case ignoreatkcard
    case ignoreelement
    case ignoredefense
    case ignoreflee
    case ignoredefcard
    case critical
    case ignorelongcard
    case simpledefense

    public var rawValue: Int {
        switch self {
        case .nodamage: 0
        case .splash: 1
        case .splashsplit: 2
        case .ignoreatkcard: 3
        case .ignoreelement: 4
        case .ignoredefense: 5
        case .ignoreflee: 6
        case .ignoredefcard: 7
        case .critical: 8
        case .ignorelongcard: 9
        case .simpledefense: 10
        }
    }

    public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .nodamage
        case 1: self = .splash
        case 2: self = .splashsplit
        case 3: self = .ignoreatkcard
        case 4: self = .ignoreelement
        case 5: self = .ignoredefense
        case 6: self = .ignoreflee
        case 7: self = .ignoredefcard
        case 8: self = .critical
        case 9: self = .ignorelongcard
        case 10: self = .simpledefense
        default: return nil
        }
    }
}

extension SkillDamageFlag: CodingKey, CodingKeyRepresentable, Decodable {
    public init?(stringValue: String) {
        switch stringValue.uppercased() {
        case "NODAMAGE": self = .nodamage
        case "SPLASH": self = .splash
        case "SPLASHSPLIT": self = .splashsplit
        case "IGNOREATKCARD": self = .ignoreatkcard
        case "IGNOREELEMENT": self = .ignoreelement
        case "IGNOREDEFENSE": self = .ignoredefense
        case "IGNOREFLEE": self = .ignoreflee
        case "IGNOREDEFCARD": self = .ignoredefcard
        case "CRITICAL": self = .critical
        case "IGNORELONGCARD": self = .ignorelongcard
        case "SIMPLEDEFENSE": self = .simpledefense
        default: return nil
        }
    }

    public init?<T>(codingKey: T) where T: CodingKey {
        self.init(stringValue: codingKey.stringValue)
    }

    public init(from decoder: any Decoder) throws {
        let container = try decoder.singleValueContainer()
        let stringValue = try container.decode(String.self)
        if let value = Self.init(stringValue: stringValue) {
            self = value
        } else {
            throw DecodingError.dataCorruptedError(in: container, debugDescription: "Could not initialize \(Self.self) from invalid string value \(stringValue)")
        }
    }
}
