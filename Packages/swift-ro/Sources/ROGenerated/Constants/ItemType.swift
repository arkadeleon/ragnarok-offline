//
//  ItemType.swift
//  RagnarokOffline
//
//  Generated by ROGenerator.
//

/// Converted from `item_types` in `common/mmo.hpp`.
public enum ItemType: Int, CaseIterable, Sendable {
    case healing = 0
    case usable = 2
    case etc = 3
    case armor = 4
    case weapon = 5
    case card = 6
    case petegg = 7
    case petarmor = 8
    case ammo = 10
    case delayconsume = 11
    case shadowgear = 12
    case cash = 18
}

extension ItemType: CodingKey {
    public var stringValue: String {
        switch self {
        case .healing: "HEALING"
        case .usable: "USABLE"
        case .etc: "ETC"
        case .armor: "ARMOR"
        case .weapon: "WEAPON"
        case .card: "CARD"
        case .petegg: "PETEGG"
        case .petarmor: "PETARMOR"
        case .ammo: "AMMO"
        case .delayconsume: "DELAYCONSUME"
        case .shadowgear: "SHADOWGEAR"
        case .cash: "CASH"
        }
    }

    public init?(stringValue: String) {
        switch stringValue.uppercased() {
        case "HEALING": self = .healing
        case "USABLE": self = .usable
        case "ETC": self = .etc
        case "ARMOR": self = .armor
        case "WEAPON": self = .weapon
        case "CARD": self = .card
        case "PETEGG": self = .petegg
        case "PETARMOR": self = .petarmor
        case "AMMO": self = .ammo
        case "DELAYCONSUME": self = .delayconsume
        case "SHADOWGEAR": self = .shadowgear
        case "CASH": self = .cash
        default: return nil
        }
    }

    public var intValue: Int? {
        rawValue
    }

    public init?(intValue: Int) {
        self.init(rawValue: intValue)
    }
}

extension ItemType: CodingKeyRepresentable {
    public var codingKey: any CodingKey {
        self
    }

    public init?<T>(codingKey: T) where T: CodingKey {
        self.init(stringValue: codingKey.stringValue)
    }
}

extension ItemType: Decodable {
    public init(from decoder: any Decoder) throws {
        let container = try decoder.singleValueContainer()
        let stringValue = try container.decode(String.self)
        if let value = Self.init(stringValue: stringValue) {
            self = value
        } else {
            throw DecodingError.dataCorruptedError(in: container, debugDescription: "Could not initialize \(Self.self) from invalid string value \(stringValue)")
        }
    }
}
