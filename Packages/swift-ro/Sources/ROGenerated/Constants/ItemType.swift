//
//  ItemType.swift
//  RagnarokOffline
//
//  Generated by ROGenerator.
//

public enum ItemType: CaseIterable, RawRepresentable, Sendable {
    case healing
    case usable
    case etc
    case armor
    case weapon
    case card
    case petegg
    case petarmor
    case ammo
    case delayconsume
    case shadowgear
    case cash

    public var rawValue: Int {
        switch self {
        case .healing: 0
        case .usable: 2
        case .etc: 3
        case .armor: 4
        case .weapon: 5
        case .card: 6
        case .petegg: 7
        case .petarmor: 8
        case .ammo: 10
        case .delayconsume: 11
        case .shadowgear: 12
        case .cash: 18
        }
    }

    public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .healing
        case 2: self = .usable
        case 3: self = .etc
        case 4: self = .armor
        case 5: self = .weapon
        case 6: self = .card
        case 7: self = .petegg
        case 8: self = .petarmor
        case 10: self = .ammo
        case 11: self = .delayconsume
        case 12: self = .shadowgear
        case 18: self = .cash
        default: return nil
        }
    }
}

extension ItemType: CodingKey, CodingKeyRepresentable, Decodable {
    public init?(stringValue: String) {
        switch stringValue.uppercased() {
        case "HEALING": self = .healing
        case "USABLE": self = .usable
        case "ETC": self = .etc
        case "ARMOR": self = .armor
        case "WEAPON": self = .weapon
        case "CARD": self = .card
        case "PETEGG": self = .petegg
        case "PETARMOR": self = .petarmor
        case "AMMO": self = .ammo
        case "DELAYCONSUME": self = .delayconsume
        case "SHADOWGEAR": self = .shadowgear
        case "CASH": self = .cash
        default: return nil
        }
    }

    public init?<T>(codingKey: T) where T: CodingKey {
        self.init(stringValue: codingKey.stringValue)
    }

    public init(from decoder: any Decoder) throws {
        let container = try decoder.singleValueContainer()
        let stringValue = try container.decode(String.self)
        if let value = Self.init(stringValue: stringValue) {
            self = value
        } else {
            throw DecodingError.dataCorruptedError(in: container, debugDescription: "Could not initialize \(Self.self) from invalid string value \(stringValue)")
        }
    }
}
