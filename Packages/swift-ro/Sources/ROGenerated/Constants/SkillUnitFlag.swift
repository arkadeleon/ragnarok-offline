//
//  SkillUnitFlag.swift
//  RagnarokOffline
//
//  Generated by ROGenerator.
//

/// Converted from `e_skill_unit_flag` in `map/skill.hpp`.
public enum SkillUnitFlag: Int, CaseIterable, Sendable {
    case noenemy = 1
    case noreiteration = 2
    case nofootset = 3
    case nooverlap = 4
    case pathcheck = 5
    case nopc = 6
    case nomob = 7
    case skill = 8
    case dance = 9
    case ensemble = 10
    case song = 11
    case dualmode = 12
    case noknockback = 13
    case rangedsingleunit = 14
    case crazyweedimmune = 15
    case removedbyfirerain = 16
    case knockbackgroup = 17
    case hiddentrap = 18
}

extension SkillUnitFlag: CodingKey {
    public var stringValue: String {
        switch self {
        case .noenemy: "NOENEMY"
        case .noreiteration: "NOREITERATION"
        case .nofootset: "NOFOOTSET"
        case .nooverlap: "NOOVERLAP"
        case .pathcheck: "PATHCHECK"
        case .nopc: "NOPC"
        case .nomob: "NOMOB"
        case .skill: "SKILL"
        case .dance: "DANCE"
        case .ensemble: "ENSEMBLE"
        case .song: "SONG"
        case .dualmode: "DUALMODE"
        case .noknockback: "NOKNOCKBACK"
        case .rangedsingleunit: "RANGEDSINGLEUNIT"
        case .crazyweedimmune: "CRAZYWEEDIMMUNE"
        case .removedbyfirerain: "REMOVEDBYFIRERAIN"
        case .knockbackgroup: "KNOCKBACKGROUP"
        case .hiddentrap: "HIDDENTRAP"
        }
    }

    public init?(stringValue: String) {
        switch stringValue.uppercased() {
        case "NOENEMY": self = .noenemy
        case "NOREITERATION": self = .noreiteration
        case "NOFOOTSET": self = .nofootset
        case "NOOVERLAP": self = .nooverlap
        case "PATHCHECK": self = .pathcheck
        case "NOPC": self = .nopc
        case "NOMOB": self = .nomob
        case "SKILL": self = .skill
        case "DANCE": self = .dance
        case "ENSEMBLE": self = .ensemble
        case "SONG": self = .song
        case "DUALMODE": self = .dualmode
        case "NOKNOCKBACK": self = .noknockback
        case "RANGEDSINGLEUNIT": self = .rangedsingleunit
        case "CRAZYWEEDIMMUNE": self = .crazyweedimmune
        case "REMOVEDBYFIRERAIN": self = .removedbyfirerain
        case "KNOCKBACKGROUP": self = .knockbackgroup
        case "HIDDENTRAP": self = .hiddentrap
        default: return nil
        }
    }

    public var intValue: Int? {
        rawValue
    }

    public init?(intValue: Int) {
        self.init(rawValue: intValue)
    }
}

extension SkillUnitFlag: CodingKeyRepresentable {
    public var codingKey: any CodingKey {
        self
    }

    public init?<T>(codingKey: T) where T: CodingKey {
        self.init(stringValue: codingKey.stringValue)
    }
}

extension SkillUnitFlag: Decodable {
    public init(from decoder: any Decoder) throws {
        let container = try decoder.singleValueContainer()
        let stringValue = try container.decode(String.self)
        if let value = Self.init(stringValue: stringValue) {
            self = value
        } else {
            throw DecodingError.dataCorruptedError(in: container, debugDescription: "Could not initialize \(Self.self) from invalid string value \(stringValue)")
        }
    }
}
