//
//  SkillUnitFlag.swift
//  RagnarokOffline
//
//  Generated by ROGenerator.
//

public enum SkillUnitFlag: CaseIterable, RawRepresentable, Sendable {
    case noenemy
    case noreiteration
    case nofootset
    case nooverlap
    case pathcheck
    case nopc
    case nomob
    case skill
    case dance
    case ensemble
    case song
    case dualmode
    case noknockback
    case rangedsingleunit
    case crazyweedimmune
    case removedbyfirerain
    case knockbackgroup
    case hiddentrap

    public var rawValue: Int {
        switch self {
        case .noenemy: 1
        case .noreiteration: 2
        case .nofootset: 3
        case .nooverlap: 4
        case .pathcheck: 5
        case .nopc: 6
        case .nomob: 7
        case .skill: 8
        case .dance: 9
        case .ensemble: 10
        case .song: 11
        case .dualmode: 12
        case .noknockback: 13
        case .rangedsingleunit: 14
        case .crazyweedimmune: 15
        case .removedbyfirerain: 16
        case .knockbackgroup: 17
        case .hiddentrap: 18
        }
    }

    public init?(rawValue: Int) {
        switch rawValue {
        case 1: self = .noenemy
        case 2: self = .noreiteration
        case 3: self = .nofootset
        case 4: self = .nooverlap
        case 5: self = .pathcheck
        case 6: self = .nopc
        case 7: self = .nomob
        case 8: self = .skill
        case 9: self = .dance
        case 10: self = .ensemble
        case 11: self = .song
        case 12: self = .dualmode
        case 13: self = .noknockback
        case 14: self = .rangedsingleunit
        case 15: self = .crazyweedimmune
        case 16: self = .removedbyfirerain
        case 17: self = .knockbackgroup
        case 18: self = .hiddentrap
        default: return nil
        }
    }
}

extension SkillUnitFlag: CodingKey, CodingKeyRepresentable, Decodable {
    public init?(stringValue: String) {
        switch stringValue.uppercased() {
        case "NOENEMY": self = .noenemy
        case "NOREITERATION": self = .noreiteration
        case "NOFOOTSET": self = .nofootset
        case "NOOVERLAP": self = .nooverlap
        case "PATHCHECK": self = .pathcheck
        case "NOPC": self = .nopc
        case "NOMOB": self = .nomob
        case "SKILL": self = .skill
        case "DANCE": self = .dance
        case "ENSEMBLE": self = .ensemble
        case "SONG": self = .song
        case "DUALMODE": self = .dualmode
        case "NOKNOCKBACK": self = .noknockback
        case "RANGEDSINGLEUNIT": self = .rangedsingleunit
        case "CRAZYWEEDIMMUNE": self = .crazyweedimmune
        case "REMOVEDBYFIRERAIN": self = .removedbyfirerain
        case "KNOCKBACKGROUP": self = .knockbackgroup
        case "HIDDENTRAP": self = .hiddentrap
        default: return nil
        }
    }

    public init?<T>(codingKey: T) where T: CodingKey {
        self.init(stringValue: codingKey.stringValue)
    }

    public init(from decoder: any Decoder) throws {
        let container = try decoder.singleValueContainer()
        let stringValue = try container.decode(String.self)
        if let value = Self.init(stringValue: stringValue) {
            self = value
        } else {
            throw DecodingError.dataCorruptedError(in: container, debugDescription: "Could not initialize \(Self.self) from invalid string value \(stringValue)")
        }
    }
}
