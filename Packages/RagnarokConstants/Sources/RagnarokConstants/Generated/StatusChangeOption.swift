//
//  StatusChangeOption.swift
//  RagnarokConstants
//
//  Generated by RagnarokOfflineGenerator.
//

/// Converted from `e_option` in `map/status.hpp`.
public enum StatusChangeOption: Int, CaseIterable, Sendable {
    case nothing = 0x0
    case sight = 0x1
    case hide = 0x2
    case cloak = 0x4
    case cart1 = 0x8
    case falcon = 0x10
    case riding = 0x20
    case invisible = 0x40
    case cart2 = 0x80
    case cart3 = 0x100
    case cart4 = 0x200
    case cart5 = 0x400
    case orcish = 0x800
    case wedding = 0x1000
    case ruwach = 0x2000
    case chasewalk = 0x4000
    case flying = 0x8000
    case xmas = 0x10000
    case transform = 0x20000
    case summer = 0x40000
    case dragon1 = 0x80000
    case wug = 0x100000
    case wugrider = 0x200000
    case madogear = 0x400000
    case dragon2 = 0x800000
    case dragon3 = 0x1000000
    case dragon4 = 0x2000000
    case dragon5 = 0x4000000
    case hanbok = 0x8000000
    case oktoberfest = 0x10000000
    case summer2 = 0x20000000
    case cart = 0x788
    case dragon = 0x7880000
    case costume = 0x38051000
}

extension StatusChangeOption: CodingKey {
    public var stringValue: String {
        switch self {
        case .nothing: "NOTHING"
        case .sight: "SIGHT"
        case .hide: "HIDE"
        case .cloak: "CLOAK"
        case .cart1: "CART1"
        case .falcon: "FALCON"
        case .riding: "RIDING"
        case .invisible: "INVISIBLE"
        case .cart2: "CART2"
        case .cart3: "CART3"
        case .cart4: "CART4"
        case .cart5: "CART5"
        case .orcish: "ORCISH"
        case .wedding: "WEDDING"
        case .ruwach: "RUWACH"
        case .chasewalk: "CHASEWALK"
        case .flying: "FLYING"
        case .xmas: "XMAS"
        case .transform: "TRANSFORM"
        case .summer: "SUMMER"
        case .dragon1: "DRAGON1"
        case .wug: "WUG"
        case .wugrider: "WUGRIDER"
        case .madogear: "MADOGEAR"
        case .dragon2: "DRAGON2"
        case .dragon3: "DRAGON3"
        case .dragon4: "DRAGON4"
        case .dragon5: "DRAGON5"
        case .hanbok: "HANBOK"
        case .oktoberfest: "OKTOBERFEST"
        case .summer2: "SUMMER2"
        case .cart: "CART"
        case .dragon: "DRAGON"
        case .costume: "COSTUME"
        }
    }

    public init?(stringValue: String) {
        switch stringValue.uppercased() {
        case "NOTHING": self = .nothing
        case "SIGHT": self = .sight
        case "HIDE": self = .hide
        case "CLOAK": self = .cloak
        case "CART1": self = .cart1
        case "FALCON": self = .falcon
        case "RIDING": self = .riding
        case "INVISIBLE": self = .invisible
        case "CART2": self = .cart2
        case "CART3": self = .cart3
        case "CART4": self = .cart4
        case "CART5": self = .cart5
        case "ORCISH": self = .orcish
        case "WEDDING": self = .wedding
        case "RUWACH": self = .ruwach
        case "CHASEWALK": self = .chasewalk
        case "FLYING": self = .flying
        case "XMAS": self = .xmas
        case "TRANSFORM": self = .transform
        case "SUMMER": self = .summer
        case "DRAGON1": self = .dragon1
        case "WUG": self = .wug
        case "WUGRIDER": self = .wugrider
        case "MADOGEAR": self = .madogear
        case "DRAGON2": self = .dragon2
        case "DRAGON3": self = .dragon3
        case "DRAGON4": self = .dragon4
        case "DRAGON5": self = .dragon5
        case "HANBOK": self = .hanbok
        case "OKTOBERFEST": self = .oktoberfest
        case "SUMMER2": self = .summer2
        case "CART": self = .cart
        case "DRAGON": self = .dragon
        case "COSTUME": self = .costume
        default: return nil
        }
    }

    public var intValue: Int? {
        rawValue
    }

    public init?(intValue: Int) {
        self.init(rawValue: intValue)
    }
}

extension StatusChangeOption: CodingKeyRepresentable {
    public var codingKey: any CodingKey {
        self
    }

    public init?<T>(codingKey: T) where T: CodingKey {
        self.init(stringValue: codingKey.stringValue)
    }
}

extension StatusChangeOption: Decodable {
    public init(from decoder: any Decoder) throws {
        let container = try decoder.singleValueContainer()
        let stringValue = try container.decode(String.self)
        if let value = Self.init(stringValue: stringValue) {
            self = value
        } else {
            throw DecodingError.dataCorruptedError(in: container, debugDescription: "Could not initialize \(Self.self) from invalid string value \(stringValue)")
        }
    }
}
