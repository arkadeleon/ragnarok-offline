//
//  ItemClasses.swift
//  RagnarokConstants
//
//  Generated by RagnarokOfflineGenerator.
//

/// Converted from `e_item_job` in `map/itemdb.hpp`.
public struct ItemClasses: OptionSet, Hashable, Sendable {
    public static let normal = ItemClasses(rawValue: 0x1)
    public static let upper = ItemClasses(rawValue: 0x2)
    public static let baby = ItemClasses(rawValue: 0x4)
    public static let third = ItemClasses(rawValue: 0x8)
    public static let third_upper = ItemClasses(rawValue: 0x10)
    public static let third_baby = ItemClasses(rawValue: 0x20)
    public static let fourth = ItemClasses(rawValue: 0x40)
    public static let all_upper = ItemClasses(rawValue: 0x52)
    public static let all_baby = ItemClasses(rawValue: 0x24)
    public static let all_third = ItemClasses(rawValue: 0x38)
    public static let all = ItemClasses(rawValue: 0x7f)

    public let rawValue: Int

    public init(rawValue: Int) {
        self.rawValue = rawValue
    }
}

extension ItemClasses: CodingKey {
    public var stringValue: String {
        switch self {
        case .normal: "NORMAL"
        case .upper: "UPPER"
        case .baby: "BABY"
        case .third: "THIRD"
        case .third_upper: "THIRD_UPPER"
        case .third_baby: "THIRD_BABY"
        case .fourth: "FOURTH"
        case .all_upper: "ALL_UPPER"
        case .all_baby: "ALL_BABY"
        case .all_third: "ALL_THIRD"
        case .all: "ALL"
        default: ""
        }
    }

    public init?(stringValue: String) {
        switch stringValue.uppercased() {
        case "NORMAL": self = .normal
        case "UPPER": self = .upper
        case "BABY": self = .baby
        case "THIRD": self = .third
        case "THIRD_UPPER": self = .third_upper
        case "THIRD_BABY": self = .third_baby
        case "FOURTH": self = .fourth
        case "ALL_UPPER": self = .all_upper
        case "ALL_BABY": self = .all_baby
        case "ALL_THIRD": self = .all_third
        case "ALL": self = .all
        default: return nil
        }
    }

    public var intValue: Int? {
        rawValue
    }

    public init?(intValue: Int) {
        self.init(rawValue: intValue)
    }
}

extension ItemClasses: Decodable {
    public init(from decoder: any Decoder) throws {
        let container = try decoder.singleValueContainer()
        let dictionary = try container.decode([String : Bool].self)
        let trueKeys = dictionary.compactMap {
            $0.value ? $0.key : nil
        }
        let falseKeys = dictionary.compactMap {
            !$0.value ? $0.key : nil
        }

        self.rawValue = 0
        for trueKey in trueKeys {
            if let member = ItemClasses(stringValue: trueKey) {
                self.insert(member)
            }
        }
        for falseKey in falseKeys {
            if let member = ItemClasses(stringValue: falseKey) {
                self.remove(member)
            }
        }
    }
}
