//
//  GeneratePacketsCommand.swift
//  RagnarokOfflineGenerator
//
//  Created by Leon Li on 2024/10/18.
//

import ArgumentParser
import Foundation
import SwiftSyntax
import SwiftSyntaxBuilder

struct GeneratePacketsCommand: ParsableCommand {
    static let configuration = CommandConfiguration(commandName: "generate-packets")

    @Argument(transform: { URL(filePath: $0, directoryHint: .isDirectory) })
    var rathenaDirectory: URL

    @Argument(transform: { URL(filePath: $0, directoryHint: .isDirectory) })
    var generatedDirectory: URL

    mutating func run() throws {
        try? FileManager.default.removeItem(at: generatedDirectory)
        try? FileManager.default.createDirectory(at: generatedDirectory, withIntermediateDirectories: true)

        try generate_packets()
        try generate_packetdb()
    }

    // MARK: - generate packets

    func generate_packets() throws {
        let dumper = ASTDumper(rathenaDirectory: rathenaDirectory)
        let asts = try [
            dumper.dump(path: "common/packets.hpp"),
            dumper.dump(path: "char/packets.hpp"),
            dumper.dump(path: "map/packets.hpp"),
        ]

        let outputName = "packets"
        var output = """
        //
        //  \(outputName).swift
        //  RagnarokPackets
        //
        //  Generated by RagnarokOfflineGenerator.
        //
        
        import BinaryIO
        
        """

        var headers: [ASTNode] = []
        for ast in asts {
            let nodes = ast.findNodes {
                $0.kind == "VarDecl" && $0.name != nil && $0.name!.hasPrefix("HEADER_")
            }

            for node in nodes {
                if !headers.contains(where: { $0.name! == node.name! }) {
                    headers.append(node)
                }
            }
        }
        for header in headers {
            let value = header.findNode(where: { $0.kind == "IntegerLiteral" })!.value!.intValue!
            output.append("\n")
            output.append("public let " + header.name! + ": Int16 = 0x" + String(value, radix: 16))
        }
        output.append("\n")

        let enumDecl = asts.last!.findEnumDecl(named: "packet_headers")!
        let enumConstantDecls = enumDecl.findEnumConstantDecls()
        for enumConstantDecl in enumConstantDecls {
            let name = enumConstantDecl.name!
            let value = enumConstantDecl.findConstantExpr()!.value!.intValue!
            output.append("\n")
            output.append("public let packet_header_" + name + ": Int16 = 0x" + String(value, radix: 16))
        }
        output.append("\n")

        var structDecls: [StructDecl] = []
        var referencedStructDecls: [StructDecl] = []

        for ast in asts {
            let packetNodes = ast.findNodes { node in
                guard node.kind == "CXXRecordDecl" else { return false }
                guard let name = node.name, name.hasPrefix("PACKET_") || name.hasPrefix("packet_") || name.hasPrefix("ZC_") else { return false }
                guard node.inner != nil else { return false }
                return true
            }

            let characterInfoNode = ast.findNode { node in
                guard node.kind == "CXXRecordDecl" else { return false }
                guard let name = node.name, name == "CHARACTER_INFO" else { return false }
                guard node.inner != nil else { return false }
                return true
            }
            if let characterInfoNode, !referencedStructDecls.contains(where: { $0.name == characterInfoNode.name }) {
                let structDecl = StructDecl(node: characterInfoNode)
                referencedStructDecls.append(structDecl)
            }

            for node in packetNodes {
                if structDecls.contains(where: { $0.name == node.name }) {
                    continue
                }

                let structDecl = StructDecl(node: node)
                structDecls.append(structDecl)

                for field in structDecl.fields {
                    let structure = switch field.type {
                    case .structure(let structure):
                        structure
                    case .array(let structure):
                        structure
                    case .fixedSizeArray(let structure, _):
                        structure
                    case .string, .fixedLengthString:
                        StructureType.char
                    }
                    guard case .custom(let name) = structure else {
                        continue
                    }
                    guard let node = ast.findNode(where: { $0.kind == "CXXRecordDecl" && $0.name == name && $0.inner != nil }) else {
                        continue
                    }
                    guard !referencedStructDecls.contains(where: { $0.name == node.name }) &&
                        !structDecls.contains(where: { $0.name == node.name }) else {
                        continue
                    }

                    print(name)

                    let structDecl = StructDecl(node: node)
                    referencedStructDecls.append(structDecl)
                }
            }
        }

        for (s, structDecl) in structDecls.enumerated() {
            switch structDecl.name {
            case "PACKET_ZC_POSITION_ID_NAME_INFO":
                var nestedStructDecl = structDecl.nestedStructs[0]
                nestedStructDecl.name = "PACKET_ZC_POSITION_ID_NAME_INFO_sub"
                referencedStructDecls.append(nestedStructDecl)
            case "packet_roulette_info_ack":
                var nestedStructDecl = structDecl.nestedStructs[0]
                nestedStructDecl.name = "packet_roulette_info_ack_sub"
                referencedStructDecls.append(nestedStructDecl)
            default:
                break
            }

            for (f, fieldDecl) in structDecl.fields.enumerated() {
                switch f {
                case 0:
                    switch fieldDecl.name {
                    case "packetType", "PacketType", "packet_id":
                        structDecls[s].fields[f].name = "packetType"
                        structDecls[s].fields[f].type = .structure(.int16)
                    default:
                        break
                    }
                case 1:
                    switch fieldDecl.name {
                    case "packetLength", "PacketLength", "packetLen", "packet_len", "packetSize", "length":
                        structDecls[s].fields[f].name = "packetLength"
                        structDecls[s].fields[f].type = .structure(.int16)
                    default:
                        break
                    }
                default:
                    break
                }

                switch fieldDecl.name {
                case "list" where structDecl.name == "packet_itemlist_normal" || structDecl.name == "packet_itemlist_equip" || structDecl.name == "ZC_STORE_ITEMLIST_NORMAL" || structDecl.name == "ZC_STORE_ITEMLIST_EQUIP":
                    structDecls[s].fields[f].type = .array(fieldDecl.type.structRef!)
                default:
                    break
                }

                if structDecl.name == "PACKET_ZC_POSITION_ID_NAME_INFO" && fieldDecl.name == "posInfo" {
                    if case .fixedSizeArray(_, let size) = fieldDecl.type {
                        structDecls[s].fields[f].type = .fixedSizeArray(.custom("PACKET_ZC_POSITION_ID_NAME_INFO_sub"), size)
                    }
                } else if structDecl.name == "packet_roulette_info_ack" && fieldDecl.name == "ItemInfo" {
                    if case .fixedSizeArray(_, let size) = fieldDecl.type {
                        structDecls[s].fields[f].type = .fixedSizeArray(.custom("packet_roulette_info_ack_sub"), size)
                    }
                } else if structDecl.name == "packet_maptypeproperty2" && fieldDecl.name == "flag" {
                    structDecls[s].fields[f].type = structDecl.nestedStructs[0].fields[0].type
                }
            }
        }

        for (s, structDecl) in referencedStructDecls.enumerated() {
            for (f, fieldDecl) in structDecl.fields.enumerated() {
                if structDecl.name == "EQUIPITEM_INFO" && fieldDecl.name == "Flag" {
                    referencedStructDecls[s].fields[f].type = structDecl.nestedStructs[0].fields[0].type
                } else if structDecl.name == "NORMALITEM_INFO" && fieldDecl.name == "Flag" {
                    referencedStructDecls[s].fields[f].type = structDecl.nestedStructs[0].fields[0].type
                }
            }
        }

        var convertibleStructDecls = structDecls + referencedStructDecls
        convertibleStructDecls.removeAll { structDecl in
            structDecl.name == "packet_quest_list_info"
        }

        let converter = PacketStructConverter(structDecls: convertibleStructDecls)
        let outputs = converter.convertAll()

        output.append("\n")
        output.append(outputs.joined(separator: "\n\n"))
        output.append("\n")

        let outputURL = generatedDirectory.appending(path: "\(outputName).swift")
        try output.write(to: outputURL, atomically: true, encoding: .utf8)
    }

    // MARK: - generate packetdb

    func generate_packetdb() throws {
        let dumper = ASTDumper(rathenaDirectory: rathenaDirectory)
        let ast = try dumper.dump(path: "map/clif.cpp")

        let readdb = ast.findFunctionDecl(named: "packetdb_readdb")!
        let addpackets = readdb.findCallExprs(fn: "packetdb_addpacket")

        var outputLines: [String] = []

        for addpacket in addpackets {
            let packetTypeNode = addpacket.inner![1].findNode { node in
                node.kind == "IntegerLiteral" || node.kind == "DeclRefExpr"
            }!
            var packetType: String
            if let intValue = packetTypeNode.value?.intValue {
                packetType = "0x" + String(intValue, radix: 16)
            } else {
                packetType = packetTypeNode.referencedDecl!.name!
                if !packetType.hasPrefix("HEADER_") {
                    packetType = "packet_header_" + packetType
                }
            }

            let packetLengthNode = addpacket.inner![2].findNode { node in
                node.kind == "IntegerLiteral" || node.kind == "UnaryExprOrTypeTraitExpr"
            }!
            var packetLength: String
            if let intValue = packetLengthNode.value?.intValue {
                packetLength = "\(intValue)"
                if addpacket.inner![2].findNode(where: { $0.kind == "UnaryOperator" && $0.opcode == "-" }) != nil {
                    packetLength = "-" + packetLength
                }
            } else if let desugaredQualType = packetLengthNode.argType?.desugaredQualType {
                packetLength = "\(desugaredQualType).size"
            } else if let qualType = packetLengthNode.argType?.qualType {
                packetLength = "\(qualType).size"
            } else {
                packetLength = ""
            }

            let functionNameNode = addpacket.inner![3].findNode { node in
                node.referencedDecl?.kind == "FunctionDecl"
            }
            let nullableFunctionName = functionNameNode?.referencedDecl?.name
            let functionName = nullableFunctionName == nil ? "nil" : "\"\(nullableFunctionName!)\""

            let offsetsNode = addpacket.inner![4...].map { node in
                node.findNode(where: { $0.kind == "IntegerLiteral" })!.value!.intValue!
            }
            let offsets = "[" + offsetsNode.dropLast().map(String.init).joined(separator: ", ") + "]"

            outputLines.append("add_packet(\(packetType), \(packetLength), \(functionName), \(offsets))")
        }

        let packetdbLines = outputLines
            .map({ "    \($0)" })
            .joined(separator: "\n")
        let packetdbOutputContents = """
        //
        //  packetdb.swift
        //  RagnarokPackets
        //
        //  Generated by RagnarokOfflineGenerator.
        //
        
        public func add_packets(_ add_packet: (Int16, Int, String?, [Int]) -> Void) {
        \(packetdbLines)
        }
        
        """

        let packetdbOutputURL = generatedDirectory.appending(path: "packetdb.swift")
        try packetdbOutputContents.write(to: packetdbOutputURL, atomically: true, encoding: .utf8)
    }
}
