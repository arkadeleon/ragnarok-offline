//
//  ConstantConverter.swift
//  RagnarokOfflineGenerator
//
//  Created by Leon Li on 2024/10/8.
//

import Foundation

class ConstantConverter {
    struct InputConstant {
        var name: String
        var value: Int
    }

    struct OutputConstant {
        var inputName: String
        var outputName: String
        var intValue: Int
        var stringValues: [String]
        var isExcluded: Bool
    }

    let rathenaDirectory: URL

    var asts: [String : ASTNode] = [:]

    init(rathenaDirectory: URL) {
        self.rathenaDirectory = rathenaDirectory
    }

    func convert(conversion: ConstantConversion) throws -> String {
        let ast: ASTNode
        if let cachedAST = asts[conversion.source] {
            ast = cachedAST
        } else {
            let dumper = ASTDumper(rathenaDirectory: rathenaDirectory)
            ast = try dumper.dump(path: conversion.source)
            asts[conversion.source] = ast
        }

        let enumDecl = ast.findEnumDecl(named: conversion.type)!
        let enumConstantDecls = enumDecl.findEnumConstantDecls()

        var inputConstants: [InputConstant] = []
        for enumConstantDecl in enumConstantDecls {
            var name = enumConstantDecl.name!
            if let replace = conversion.replace[name] {
                name = replace
            }

            let value: Int? = if let value = enumConstantDecl.findConstantExpr()?.value?.intValue {
                value
            } else if let lastValue = inputConstants.last?.value {
                lastValue + 1
            } else {
                nil
            }

            let constant = InputConstant(name: name, value: value ?? 0)
            inputConstants.append(constant)
        }
        for insert in conversion.insert {
            let constant = InputConstant(name: insert.0, value: insert.1)
            inputConstants.append(constant)
        }

        var outputConstants: [OutputConstant] = []
        for inputConstant in inputConstants {
            let inputName = inputConstant.name

            var outputName = inputName
            if outputName.hasPrefix(conversion.prefix) {
                outputName = String(outputName.dropFirst(conversion.prefix.count))
            }
            if outputName.hasSuffix(conversion.suffix) {
                outputName = String(outputName.dropLast(conversion.suffix.count))
            }
            if let outputPrefix = conversion.outputPrefix {
                outputName = outputPrefix + outputName
            }
            outputName = outputName.lowercased()
            let digits = try Regex("[0-9]+")
            if outputName.starts(with: digits) {
                outputName = "_" + outputName
            } else if outputName == "class" || outputName == "repeat" || outputName == "self" {
                outputName = "_" + outputName
            }

            var stringValues = [inputName]
            if let compatible = conversion.compatible[inputName] {
                stringValues.append(contentsOf: compatible)
            }
            stringValues = stringValues.map {
                var stringValue = $0
                if stringValue.hasPrefix(conversion.prefix) {
                    stringValue = String(stringValue.dropFirst(conversion.prefix.count))
                }
                if stringValue.hasSuffix(conversion.suffix) {
                    stringValue = String(stringValue.dropLast(conversion.suffix.count))
                }
                return stringValue
            }

            let constant = OutputConstant(
                inputName: inputName,
                outputName: outputName,
                intValue: inputConstant.value,
                stringValues: stringValues,
                isExcluded: conversion.exclude.contains(inputConstant.name)
            )
            outputConstants.append(constant)
        }
        outputConstants = outputConstants.filter {
            !$0.isExcluded
        }

        var outputContents = ""

        switch conversion.kind {
        case .cEnum:
            outputContents = """
            //
            //  \(conversion.outputType).swift
            //  RagnarokOffline
            //
            //  Generated by RagnarokOfflineGenerator.
            //
            
            /// Converted from `\(conversion.type)` in `\(conversion.source)`.
            
            """

            if conversion.extensions.contains(.rawRepresentable) {
                let casesContents = outputConstants
                    .map {
                        "    case \($0.outputName)"
                    }
                    .joined(separator: "\n")

                let rawValueContents = outputConstants
                    .map {
                        let value = switch conversion.outputFormat {
                        case .decimal:
                            String($0.intValue, radix: 10)
                        case .hex:
                            "0x" + String($0.intValue, radix: 16)
                        }
                        return "        case .\($0.outputName): \(value)"
                    }
                    .joined(separator: "\n")

                let initRawValueContents = outputConstants
                    .map {
                        let value = switch conversion.outputFormat {
                        case .decimal:
                            String($0.intValue, radix: 10)
                        case .hex:
                            "0x" + String($0.intValue, radix: 16)
                        }
                        return "        case \(value): self = .\($0.outputName)"
                    }
                    .joined(separator: "\n")

                outputContents.append("""
                public enum \(conversion.outputType): CaseIterable, Sendable {
                \(casesContents)
                }
                
                extension \(conversion.outputType): RawRepresentable {
                    public var rawValue: Int {
                        switch self {
                \(rawValueContents)
                        }
                    }
                
                    public init?(rawValue: Int) {
                        switch rawValue {
                \(initRawValueContents)
                        default: return nil
                        }
                    }
                }
                
                """)
            } else {
                let casesContents = outputConstants
                    .map {
                        let value = switch conversion.outputFormat {
                        case .decimal:
                            String($0.intValue, radix: 10)
                        case .hex:
                            "0x" + String($0.intValue, radix: 16)
                        }
                        return "    case \($0.outputName) = \(value)"
                    }
                    .joined(separator: "\n")

                outputContents.append("""
                public enum \(conversion.outputType): Int, CaseIterable, Sendable {
                \(casesContents)
                }
                
                """)
            }

            if conversion.extensions.contains(.decodable) {
                let stringValueContents = outputConstants
                    .map {
                        "        case .\($0.outputName): \"\($0.stringValues[0])\""
                    }
                    .joined(separator: "\n")

                let initStringValueContents = outputConstants
                    .map {
                        let stringValues = $0.stringValues
                            .map {
                                "\"\($0)\""
                            }
                            .joined(separator: ", ")

                        return "        case " + stringValues + ": self = .\($0.outputName)"
                    }
                    .joined(separator: "\n")

                outputContents.append("""
                
                extension \(conversion.outputType): CodingKey {
                    public var stringValue: String {
                        switch self {
                \(stringValueContents)
                        }
                    }
                
                    public init?(stringValue: String) {
                        switch stringValue.uppercased() {
                \(initStringValueContents)
                        default: return nil
                        }
                    }
                
                    public var intValue: Int? {
                        rawValue
                    }
                
                    public init?(intValue: Int) {
                        self.init(rawValue: intValue)
                    }
                }
                
                extension \(conversion.outputType): CodingKeyRepresentable {
                    public var codingKey: any CodingKey {
                        self
                    }
                
                    public init?<T>(codingKey: T) where T: CodingKey {
                        self.init(stringValue: codingKey.stringValue)
                    }
                }
                
                extension \(conversion.outputType): Decodable {
                    public init(from decoder: any Decoder) throws {
                        let container = try decoder.singleValueContainer()
                        let stringValue = try container.decode(String.self)
                        if let value = Self.init(stringValue: stringValue) {
                            self = value
                        } else {
                            throw DecodingError.dataCorruptedError(in: container, debugDescription: "Could not initialize \\(Self.self) from invalid string value \\(stringValue)")
                        }
                    }
                }
                
                """)
            }
        case .optionSet:
            outputContents = """
            //
            //  \(conversion.outputType).swift
            //  RagnarokOffline
            //
            //  Generated by RagnarokOfflineGenerator.
            //
            
            /// Converted from `\(conversion.type)` in `\(conversion.source)`.
            
            """

            let casesContents = outputConstants
                .map {
                    let value = "0x" + String($0.intValue, radix: 16)
                    return "    public static let \($0.outputName) = \(conversion.outputType)(rawValue: \(value))"
                }
                .joined(separator: "\n")

            outputContents.append("""
            public struct \(conversion.outputType): OptionSet, Hashable, Sendable {
            \(casesContents)
            
                public let rawValue: Int
            
                public init(rawValue: Int) {
                    self.rawValue = rawValue
                }
            }
            
            """)

            if conversion.extensions.contains(.decodable) {
                let stringValueContents = outputConstants
                    .map {
                        "        case .\($0.outputName): \"\($0.stringValues[0])\""
                    }
                    .joined(separator: "\n")

                let initStringValueContents = outputConstants
                    .map {
                        let stringValues = $0.stringValues
                            .map {
                                "\"\($0)\""
                            }
                            .joined(separator: ", ")

                        return "        case " + stringValues + ": self = .\($0.outputName)"
                    }
                    .joined(separator: "\n")

                outputContents.append("""
                
                extension \(conversion.outputType): CodingKey {
                    public var stringValue: String {
                        switch self {
                \(stringValueContents)
                        default: ""
                        }
                    }
                
                    public init?(stringValue: String) {
                        switch stringValue.uppercased() {
                \(initStringValueContents)
                        default: return nil
                        }
                    }
                
                    public var intValue: Int? {
                        rawValue
                    }
                
                    public init?(intValue: Int) {
                        self.init(rawValue: intValue)
                    }
                }
                
                extension \(conversion.outputType): Decodable {
                    public init(from decoder: any Decoder) throws {
                        let container = try decoder.singleValueContainer()
                        let dictionary = try container.decode([String : Bool].self)
                        let trueKeys = dictionary.compactMap {
                            $0.value ? $0.key : nil
                        }
                        let falseKeys = dictionary.compactMap {
                            !$0.value ? $0.key : nil
                        }

                        self.rawValue = 0
                        for trueKey in trueKeys {
                            if let member = \(conversion.outputType)(stringValue: trueKey) {
                                self.insert(member)
                            }
                        }
                        for falseKey in falseKeys {
                            if let member = \(conversion.outputType)(stringValue: falseKey) {
                                self.remove(member)
                            }
                        }
                    }
                }
                
                """)
            }
        }

        return outputContents
    }
}
